\documentclass[10pt]{article}
\usepackage[margin=2cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{amsthm}
\usepackage{physics}
\usepackage{amsfonts}
\usepackage{graphics}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}
\lstset{style=mystyle}
\usepackage[ruled,vlined]{algorithm2e}
\SetKw{KwBy}{by}

\title{Babai Point Asynchronous Implementation Report}

\author{
	\IEEEauthorblockN{Shilei Lin} \\
	\IEEEauthorblockA{ID: 260887631\\ School of Computer Science\\
		McGill University\\
		shilei.lin@mail.mcgill.ca}
}


\date{October 05, 2020}

\begin{document}
	
	\maketitle
	\section{Data Representations}
	The algorithm of finding the Babai point in my implementation is written in C++. The matrix and vector are initialized by the \textit{Eigen}\footnote{\url{http://eigen.tuxfamily.org/index.php?title=Main_Page}} Library.
	The reason I chose \textit{Eigen} is that it is a widely used C++ library for doing some numerical computations. Especially, for our purposes, I use \textit{Eigen} to randomly generate an $n$ by $n$ matrix $A$, then use \textit{Eigen::HouseholderQR} to perform the \textit{QR} decomposition on $A$, to obtain the upper triangular matrix $R$.
	\section{Initial point}
	The initial point $x_0$ and RHS vector $y$ are generated by the following code in the class constructorï¼š
	\begin{lstlisting}[language=c++]
		std::random_device rd;
		std::mt19937 gen(rd());  //here you could also set a seed
		std::uniform_real_distribution<double> dis(-n, n);
		
		this->x0 = Eigen::VectorXd::Zero(n).unaryExpr([&](int dummy) { return round(dis(gen)); });
		this->y = R * x0 + 10 * VectorXd::Random(n); //VectorXd::Random(n) can generate a random nx1 vector in range [-1,1].
	\end{lstlisting}
	\section{Computer Specification}
	My own desktop's CPU is an Intel Core i7-8700k, which is an 6 cores/12 threads CPU. When starting the OpenMp parallel pool, I created 12 threads:
	\begin{lstlisting}[language=c++]
		int Max_threads = omp_get_max_threads();
		std::cout<<"Max_threads="<< MAX_JOB <<std::endl;
		
		int n = 1000, nswp = 6, n_jobs = 12;
	\end{lstlisting}
	Then, inside the solver function, before the for-loops, the parallel region starts like:
	\begin{lstlisting}[language=c++]
		#pragma omp parallel num_threads(n_proc) private(sum) shared(raw_x)
	\end{lstlisting}
	In the future, I can test the code on my GPU, a GTX Nvidia 1080, which has 2560 Cuda cores.  
	\section{The residual of the Babai point and the running time}
	\begin{enumerate}
		\item For matrix size as 1000 by 1000: \\
		The residual for regular Babai point is \textbf{120.38121}, and the running time is \textbf{0.075084} seconds. Then, for the parallel Babai point, the results are as following:
		\begin{enumerate}
			\item For 0 "sweeps", the residual is 321.83642, and the running time is 0.000000 seconds
			\item For 1 "sweeps", the residual is 5277.48836, and the running time is 0.004534 seconds
			\item For 2 "sweeps", the residual is 1451.05695, and the running time is 0.008898 seconds
			\item For 3 "sweeps", the residual is 423.29749, and the running time is 0.013278 seconds
			\item For 4 "sweeps", the residual is 127.02070, and the running time is 0.017914 seconds
			\item For 5 "sweeps", the residual is 121.15369, and the running time is 0.023582 seconds
			\textbf{\item For 6 "sweeps", the residual is 120.25204, and the running time is 0.026964 seconds}
			\item For 7 "sweeps", the residual is 120.41889, and the running time is 0.031064 seconds
			\textbf{\item For 8 "sweeps", the residual is 120.38121, and the running time is 0.035442 seconds}
			\item For 9 "sweeps", the residual is 120.38121, and the running time is 0.041011 seconds
			\item For 10 "sweeps", the residual is 120.38121, and the running time is 0.044826 seconds
			\item For 11 "sweeps", the residual is 120.38121, and the running time is 0.049399 seconds
			\item For 12 "sweeps", the residual is 120.38121, and the running time is 0.053094 seconds
		\end{enumerate}
		Clearly, after 8 sweeps, the result converged to the regular Babai point, and the running time is also faster than the regular version. Also, noticeably, that at the sixth sweep, the residual is even smaller than the regular version.(But I may need to investigate why this happened in the future).
		\item For matrix size as 2000 by 2000:  the residual for regular Babai point is \textbf{234.85885}, and the running time is \textbf{0.294} seconds. Then, for the parallel Babai point, the results are as following:
		\begin{enumerate}
			\item For 0 "sweeps", the residual is 261.96518, and the running time is 0.000000 seconds
			\item For 1 "sweeps", the residual is 1986.01265, and the running time is 0.017821 seconds
			\item For 2 "sweeps", the residual is 765.52382, and the running time is 0.035294 seconds
			\item For 3 "sweeps", the residual is 270.05316, and the running time is 0.053627 seconds
			\item For 4 "sweeps", the residual is 246.01876, and the running time is 0.070473 seconds
			\item For 5 "sweeps", the residual is 241.38594, and the running time is 0.088520 seconds
			\item For 6 "sweeps", the residual is 234.90108, and the running time is 0.106270 seconds
			\item For 7 "sweeps", the residual is 235.72692, and the running time is 0.124928 seconds
			\textbf{\item For 8 "sweeps", the residual is 234.85885, and the running time is 0.141407 seconds}
			\item For 9 "sweeps", the residual is 234.85885, and the running time is 0.158683 seconds
			\item For 10 "sweeps", the residual is 234.85885, and the running time is 0.175248 seconds
			\item For 11 "sweeps", the residual is 234.85885, and the running time is 0.196180 seconds
			\item For 12 "sweeps", the residual is 234.85885, and the running time is 0.211432 seconds
		\end{enumerate}
		Clearly, after 8 sweeps, the result converged to the regular Babai point, and the running time is also faster than the regular version.
	\end{enumerate}
	
	\section{Comments on the results}
	There are some remarks that I want to make.\\
	
	\noindent The $R$ upper triangular matrix in the parallel version is compressed and not stored as \textit{Eigen} datatype. Since the half of the $R$ matrix is filled with 0s, the actually number of entries that need to be stored is $n(n-1)/2$. Then I put all nonzero entries into a C++ standard $std::vector<double>$, which actually speed up the program a lot.\\
	
	\noindent Also, the visual studio 2019 only supports OpenMp 2.0 but the latest version is 4.0. So if the result is sound, then I can test the code in Linux with OpenMp 4.0 which has some new parallel functions built in. Furthermore, as I have mentioned in section 3, I have not yet run the code with my GPU.\\
	
	
	% \begin{algorithm}[H]
	% \SetAlgoLined
	% \KwResult{Return $Z_b$ as the Babai point}
	%  \{initialization\} 
	%  Set $k\coloneqq n$, $\beta^2\coloneqq\infty$, and $\text{prsd} \coloneqq \text{zeros}(n,1)$\;
	%  Compute $c_n \coloneqq y_n/R_{n,n}$, $z_n\coloneqq\text{round}(c_n)$\;
	%  Set $d_k \coloneqq c_k > z_k? 1:-1$\;
	%  \While{1}{
	%   $new\text{prsd} \gets prsd_k + \gamma^2$ \;
	%   \eIf{$newprsd >\coloneqq b$}{
	%   \eIf{$k = n$}{
	%       terminate
	%   }{
	%       $k \gets k + 1, z_k \gets z_k+d_k$, and  $\gamma \coloneqq R_{k,k} \cdot (c_k - z_k)$\;
	%       Set $d_k > 0? d_k\coloneqq-d_k-1:d_k\coloneqq1-d_k$\;
	
	%   }
	%   }{
	%     \eIf{$k ~\coloneqq n$}{
	%         Set $k \gets k - 1, z_k \gets z_k+d_k$, and $\gamma \coloneqq R_{k,k} \cdot (c_k - z_k)$\;
	%         Begin parallel region and launch threads\;
	%       \For{$i_{swp}\gets1$ \KwTo $n_{swp}$ \KwBy $1$}{
	%       (in parallel dynamically)
	%             \For{$i\gets1$ \KwTo $n$ \KwBy $1$}{
	%                 $c_k\gets\Big(y_k - \sum_{j=k+1}^n R_{k,j}z_j\Big)/R_{k,k}$\;
	%                 Set $z_k\coloneqq\text{round}(c_k)$\;
	%                 Set $prsd_k \coloneqq newprsd$, and $\gamma \coloneqq R_{k,k} \cdot (c_k - z_k)$\;
	%                 Set $d_k \coloneqq c_k > z_k? 1:-1$\;
	%             }
	%         }
	%     }{
	%         Save $z_b \coloneqq z$\;
	%         Set $b \coloneqq newprsd, z_1 \coloneqq z_1+ d_1$, and $\gamma \coloneqq R_{1,1} \cdot (c_1 - z_1)$\;
	%         Set $d_k > 0? d_k\coloneqq-d_k-1:d_k\coloneqq1-d_k$\;
	%     }
	%   }
	%  }
	%  \caption{Asynchronous Search Process for Babai point}
	% \end{algorithm}
	
\end{document}
